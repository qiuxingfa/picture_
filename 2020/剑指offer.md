# 剑指offer

## 第1章 面试的流程

### 1.1 面试官谈面试

* 考察算法和数据结构
* 对公司近况、项目有所了解，对应聘的工作很有热情
* 和面试官多做沟通，做一些整体的设计和规划

### 1.2 面试的3种形式

* 电话面试
  * 不确定面试官问题时，大但向面试官提问
* 远程面试
  * 思考清楚再开始编码
  * 良好的代码命名和缩进
  * 能够进行单元测试
  * 主要是编程习惯和调试能力
* 现场面试

### 1.3 面试的3个环节

* 行为面试
  * 30秒到1分钟介绍自己的主要学习工作经历
  * 项目经历：简短的项目背景、自己完成的任务、为完成任务做了哪些工作、自己的贡献
* 技术面试
  * 基础知识：编程语言、数据结构、算法
  * 高质量的代码
  * 清晰的思路
  * 优化效率的能力
  * 优秀的综合能力

* 应聘者提问

## 第2章 面试需要的基础知识

### 2.2 编程语言

### 2.3 数据结构

1. 赋值运算符函数
2. 实现Singleleton模式
3. 找出数组中的重复数字
   * 排序扫描

   * 哈希表

   * 与下标进行对比
   * 不修改数组找出重复的数字
      * 逐一把原数组的数字复制到辅助数组中
      * 类似二分法，判断值为1-m的数字数目是否大于m
4. 二维数组中的查找

   * 选取数组右上角（左下角）的数字进行比较，删除所在列或行
5. 替换空格

   * 扫描，替换
   * 统计空格数，从后面开始复制和替换
6. 从尾到头打印链表
7. 重建二叉树
   * 递归地构建左右子树，前序遍历的第一个节点为根节点，中序遍历的根节点左边为左子树，右边为右子树
8. 二叉树的下一个节点
   * 分情况分析
9. 用两个栈实现队列
   * push时插入栈A，pop时将栈A数据插入栈B然后输出栈删除的第一个数

### 2.4 算法和数据操作

10. 斐波那契数列
    * 根据函数定直接写出的函数存在很多重复的计算
    * 从下往上计算，根据f(n-2)和f(n-1)计算f(n)
    * 根据数学公式进行矩阵运算（比较复杂，不太实用）
    * 青蛙跳台问题：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级台阶共有多少种跳法。（扩展：青蛙一次可以有n种跳法，f(n)=2^(n-1)）
    * 用2×1的小矩形横着或者竖着去覆盖更大的矩形。请问用8个2×1的小矩形无重复地覆盖一个2×8的大矩形，总共有多少种方法
11. 旋转数组的最小数字
    * 二分查找法，用两个指针指向首尾，并和中间元素进行比较
12. 矩阵中的路径
    * 回溯法
13. 机器人的运动范围
    * 回溯法
14. 剪绳子
    * 动态规划，将问题分解为小问题
    * 贪婪算法，n>=5时，尽可能地多剪长度为3的绳子，当剩下的绳子长度为4时，把绳子减成两端长度为2的绳子，证明：3(n-3) >= 2(n-2)
15. 二进制中1的个数
    * 常规解法，首先把n 和1 做与运算， 判断n 的最低位是不是为1 。接着把1 左移一位得到2, 再和n 做与运算， 就能判断n 的次低位是不是1 … 这样反复左移，每次都能判断n 的其中一位是不是1。
    * 把一个整数减去1 ，再和原整数做与运算， 会把该整数最右边的1变成0。那么一个整数的二进制表示中有多少个1,就可以进行多少次这样的操作。

## 第3章 高质量的代码

### 3.2 代码的规范性

* 清晰的书写，清晰的不具，合理的命名

### 3.3 代码的完整性

* 把尽可能的输入都想清楚，考虑各种边界值的测试用例，考虑各种可能的错误输入
* 错误处理方法：
  * 函数用返回值来告知调用者是否出错
  * 当错误发生时设置一个全局变量
  * 异常

16. 数值的整数次方
    * 分情况讨论
    * 按指数为奇数偶数的情况分，用递归的方法实现
17. 打印从1到最大的n位数
    * 可能存在大数问题
    * 用字符串表示数字
18. 删除链表的节点
    * 遍历查找要删除的节点
    * 先把i节点的下一个节点j的内容复制到i，然后把i的指针指向节点j的下一个节点，此时再删除节点j，如果要删除的节点位于链表的尾部，那么就需要进行顺序遍历
    * 删除链表中的重复节点
19. 正则表达式匹配
    * 当模式为'.'或者字符和模式相互匹配时，则接着匹配后面的字符，当模式中第二个字符为'*'时，分析匹配方式的不同情况
20. 表示数值的字符串
    * 表示数值的字符串遵循模式A[.\[B\]][e|EC] 或者B[e|EC] ，其中A 为数值的整数部分， B紧跟着小数点为数值的小数部分，C紧跟着'e'或者'E'为数值的指数部分。
21. 调整数据顺序使奇数位于偶数前面
    * 不考虑时间复杂度，扫描数组，每碰到一个偶数，将后面的数字向前移一位，将改数放到最后
    * 维护两个指针，第一个指针指向数组的第一个数字，它只向后移动，第二个指针指向数组的最后一个数字，它只向前移动

### 3.4 代码的鲁棒性

22. 链表中倒数第k个节点
    * 遍历两次，第一次得到节点数n，第二次得到前进的步数n-k+1
    * 定义两个指针，当第一个指针指向第k个节点时，启动第二个指针，所以当第二个指针指向结尾时，第一个指针即为倒数第k个节点，要特别注意输入异常的情况
    * 求链表的中间节点。定义两个指针，第一个指针走一步第二个指针走两步。
23. 链表中环的入口节点
    * 首先用两个指针得到环中节点的数目k，再用两个相隔k的指针得到环的入口
24. 反转链表
    * 定义前一节点，当前节点，后一节点三个指针
25. 合并两个排序的链表
    * 使用递归方法，充分考虑两个链表的不同情况
26. 树的子结构
    * 使用递归的方法遍历

## 第4章 解决面试题的思路

### 4.2  画图让抽象问题形象化

27. 二叉树的镜像
    * 先前序遍历这棵树的每个节点，如果遍历到的节点有子节点，就交换它的两个子节点，当交换完所有非叶子节点的左右子节点之后，就得到了树的镜像
28. 对称的二叉树
    * 通过比较二叉树的前序遍历和对称前序遍历是否相同来判断
29. 顺时针打印矩阵
    * 让循环继续的条件是columns>startX\*2 并且 rows > startY\*2，仔细分析打印时每一步的前提条件

### 4.3 举例让抽象问题具体化

30. 包含min函数的栈
    * 使用另一个栈保存最小值
31. 栈的压入、弹出序列
    * 如果下一个弹出的数字刚好是栈顶数字，那么直接弹出，如果下一个弹出的数字不在栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止，如果所有数字都压入栈后仍没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列
32. 从上到下打印二叉树
    * 每打印一个节点时，把该节点的子节点放入队列中，直至队列中所有节点都被打印
    * 分行从上到下打印二叉树，需保存当前层还没有打印的节点数和下一层的节点数
    * 之字形打印二叉树，打印某一层节点时，把下一层的子节点保存到相应的栈里，如果当前打印的是奇数层，则先保存左子节点，再保存右子节点到以一个栈，如果当前打印的是偶数层，则先保存右子节点再保存左子节点到第二个栈
33. 二叉搜索树的后序遍历序列
    * 最后一个数字是根节点，前面小于根节点的为左子树，后面大于根节点的为右子树，顺序不能乱，用递归
34. 二叉树中和为某一值的路径
    * 前序遍历到某一节点时，把该节点添加到路径上，并累加该节点的值，如果该节点为叶节点，并且路径中节点值的和刚好等于输入的整数，则当前路径符合要求，当前节点访问结束后，自动回到它的父节点

### 4.4 分问题让复杂问题简单化

35. 复杂链表的复制
    * 第一步将每个节点N链接到复制节点N‘，第二步复制节点的随机链接，然后把长链分成两个链表，偶数节点就是复制出来的链表







---

# Leetcode

### 1. 两数之和

* 先排序，然后首位递进查找，时间复杂度为O(nlogn)
* 用字典搜索，时间复杂度为O(n)

### 2. 两数相加

* 使用变量来跟踪进位，考虑两个数长短不一的情况，考虑两个数相加后位数大于原来的数的情况

### 3. 无重复字符的最长字串

* 定义字符到索引的映射，当找到重复字符时，立即跳过该窗口，时间复杂度O(n),空间复杂度O(min(m,n))

### 4. 寻找两个有序数组的中位数

* 二分法，时间复杂度O(log(m+n))

### 5. 最长回文字符串

* 动态规划-中心扩散法

### 6. Z字形变换

* 从左到右迭代s，将每个字符添加到合适的行

### 7.整数反转

### 8. 字符串转整数

### 9. 回文数

* 将整数拆解，看是否回文

### 10. 正则表达式匹配

### 11. 盛水最多的容器

* 双指针法

### 12. 整数转罗马数字

* 贪心算法

### 13. 罗马数字转整数

* 小的在左边做减法，在右边做加法

### 14. 最长公共前缀

* 水平扫描

### 15. 三树之和

* 先排序，再用两个指针寻找，跳过重复值

### 16. 最接近的三数之和

* 先排序，后用双指针

### 17. 电话号码的字母组合

* 回溯法

### 18. 四数之和

* 排序后双指针

### 19. 删除链表的倒数第N个节点

* 两个指针相差n，快的指针到达结尾时，慢的指针即为所求节点

### 20. 有效的括号

* 使用栈存储，配对成功弹出，最后栈为空则为有效

### 21.合并两个有序链表

* 递归，每次返回更小的头节点
* 迭代，循环判断

### 22. 括号生成

* 回溯法

### 23. 合并k个排序链表

* 遍历所有链表，将所有节点的值放入数组，排序，新建有序链表
* 逐一比较
* 逐一两两合并
* 分治

### 24. 两两交换链表中的节点

* 递归
* 迭代，三指针

### 25. k个一组翻转链表

* 基本同24

### 26. 删除排序数组的重复项

* 两个指针，遇到重复跳过

### 27. 移除元素

* 同26，两个指针

### 28. 实现strStr()

* 滑动窗口
* 双指针

### 29. 两数相除

### 30. 串联所有单词的字串

### 31. 下一个排列

* 先找出最大的索引 k 满足 nums[k] < nums[k+1]，如果不存在，就翻转整个数组；再找出另一个最大索引 l 满足 nums[l] > nums[k]；交换 nums[l] 和 nums[k]；最后翻转 nums[k+1:]

### 32. 最长的有效括号

### 33. 搜索旋转排序数组

* 二分查找，判断target在左边还是右边

### 34. 在排序数组中查找元素的第一个和最后一个位置

* 用二分法，先找左边界，再找找右边界

### 35.搜索插入位置

* 二分查找

### 36. 有效的数独

* 用三个字典存储，进行一次遍历

### 37. 解数独

* 回溯法

### 38. 外观数列

### 39. 组合总和

* 回溯算法+剪枝

### 53. 最大子序和

* 贪心，每一步都选择最佳方案
* 分治

![](https://pic.leetcode-cn.com/3aa2128a7ddcf1123454a6e5364792490c5edff62674f3cfd9c81cb7b5e8e522-file_1576478143567)

### 58. 最后一个单词的长度

* 从后向前遍历，从第一个不是空格的字符开始

### 66. 加一

### 67. 二进制求和

* 逐位运算
* 位操作

### 69. x的平方根

* 二分查找

### 70. 爬楼梯

* 斐波那契数列，动态规划

$$
dp[i] = dp[i-1] + dp[i-2]
$$

### 83. 删除链表中的重复元素

### 88. 合并两个有序数组

* 合并后排序
* 双指针，从前往后，从后往前

### 100. 相同的树

* 递归
* 迭代

### 101.对称二叉树

* 递归，(t1.val == t2.val)&& isMirror(t1.right, t2.left)&& isMirror(t1.left, t2.right
* 迭代，用队列判断，连续两个点应该时相等的，两个节点的左右子节点按相反的方向插入队列

### 104. 二叉树的最大深度

* 递归（深度优先）
* 借用栈进行迭代

### 107. 二叉树的层次遍历 II

* 层序遍历后逆序

### 108. 将有序数组转换为二叉搜索树

### 110. 平衡二叉树

* 自顶向下的递归，如果有一边子树不存在，则应该等于另一边的深度

### 112. 路径总和

* 递归

### 118. 杨辉三角

* 动态规划

### 119. 杨辉三角 II

* 公式 C(n,m) = n!/(n-m)!*m!
* 第i+1项是第i项的 (n-i)/(i+1) 倍

### 121. 买股票的最佳时机

* 遍历一遍数组，维护两个变量，截至当前的历史最低价和截至当前的最大利润

### 122. 买股票的最佳时机 II

* 贪心算法，if (prices[i] > prices[i - 1])   maxprofit += prices[i] - prices[i - 1]

### 125. 验证回文串

### 136. 只出现一次的数字

* 列表
* 哈希表
* 2 * sum(set(nums)) - sum(nums)
* 位操作

### 141. 环形链表

* 双指针

### 155. 最小栈

* 辅助栈和数据栈同步

### 160.相交链表

* 哈希表法：把A中每个结点的地址和应用存储在哈希表中
* 双指针，pA到达链表的尾部时，将它重新定位到B的头节点，pB到达链表的尾部时，将它重新定位到A的头节点，若在某个时刻pA和pB相遇，则为相交结点

### 167. 两数之和 II - 输入有序数组

* 双指针

### 169. 多数元素

* 哈希表
* 排序，返回中间那个数

### 171. Excel表列序号

* 26进制

### 189. 旋转数组

### 191. 位1的个数

* 循环
* 位移动

### 198.打家劫舍

* 动态规划，

$$
f(k) = max(f(k-2)+A_k,f(k-1))
$$

### 203. 移除链表元素

* 哨兵节点-伪头

### 205. 同构字符串

* 哈希表

### 206. 反转链表

* 迭代，三个指针
* 递归

### 217. 存在重复元素

### 219. 存在重复元素 II

* 

### 226. 翻转二叉树

* 递归
* 迭代

###  234. 回文链表

* 复制到数组后用双指针
* 递归
* 定义快慢指针，快的到达末端时，慢的到达中间，反转后半部分进行比较

### 283. 移动零

* 第一次遍历时，j指针记录非0个数，将非0的数赋值给nums[j]，第二次遍历法末尾的元素都赋值为0
* 使用两个指针i和j，只要nums[i]!=0，就交换nums[i]和nums[j]

### 437. 路径总和 III

* dfs和递归

### 448. 找到所有数组中消失的数字

* 将所有数作为数组下标，置对应数为负数，仍为正数的位置即为未出现过的数

### 461. 汉明距离

* 内置位计数功能
* 移位计数

### 538. 把二叉搜索树转换为累加树

* 回溯法，判断当前节点是否存在，存在几句递归右子树，然后更新总和和当前节点值，然后递归左子树
* 使用栈迭代

### 543.二叉树的直径

* 深度优先搜索，定义递归函数depth计算子树深度，子树深度为max(L, R) + 1，最大节点数为 L + R + 1

### 581. 最短无序连续子数组

* 排序后比较
* 使用栈
* 不使用额外空间，无序数组中最小元素的正确位置可以决定左边界，最大元素的正确位置可以决定右边界

### 617. 合并二叉树

* 递归，对两棵树进行前序遍历，将对应的节点进行合并
* 迭代，利用栈





